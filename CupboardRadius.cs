using Oxide.Core;
using Oxide.Core.Plugins;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("CupboardRadius", "playrust.io / dcode", "1.2.0", ResourceId = 1316)]
    public class CupboardRadius : RustPlugin
    {
        // Do not edit this file anymore: There is a config file now.

        protected override void LoadDefaultConfig() {
            Config["cupboardRadius"] = 25;
            Config["ignoreInfluenceRestriction"] = false;
        }

        private int radius;
        private bool ignoreInfluence;
        private CupboardRadiusPersistence pst = null;
        private bool initialized = false;

        [HookMethod("OnServerInitialized")]
        private void onServerInitialized() {
            if (initialized)
                return;
            LoadConfig();
            radius = Config.Get<int>("cupboardRadius");
            ignoreInfluence = Config.Get<bool>("ignoreInfluenceRestriction");

            Puts("Using a radius of {0}, {1} influence restrictions", radius, ignoreInfluence ? "ignoring" : "not ignoring");

            bool reloaded = false;
            foreach (var prevPst in ServerMgr.Instance.gameObject.GetComponents<MonoBehaviour>()) {
                if (prevPst.GetType().Name == "CupboardRadiusPersistence") {
                    reloaded = true;
                    pst = ServerMgr.Instance.gameObject.AddComponent<CupboardRadiusPersistence>();
                    pst.influenceIgnored = (bool)prevPst.GetType().GetField("influenceIgnored").GetValue(prevPst);
                    pst.influenceBackup = (SocketMod[])prevPst.GetType().GetField("influenceBackup").GetValue(prevPst);
                    UnityEngine.Object.Destroy(prevPst);
                    break;
                }
            }
            if (!reloaded)
                pst = ServerMgr.Instance.gameObject.AddComponent<CupboardRadiusPersistence>();

            var bpts = UnityEngine.Object.FindObjectsOfType<BuildPrivilegeTrigger>();
            var updated = 0;
            foreach (var bpt in bpts)
                if (updateTrigger(bpt))
                    ++updated;

            Puts("Updated {0} of {1} cupboards to use a sphere trigger", updated, bpts.Length);

            if (bpts.Length > 0)
                updateInfluence(bpts[0].privlidgeEntity.prefabID);

            initialized = true;
        }

        [HookMethod("OnEntitySpawned")]
        private void onEntitySpawned(BaseNetworkable ent) {
            if (!initialized || !(ent is BuildingPrivlidge))
                return;

            updateInfluence(ent.prefabID);

            var trig = ent.GetComponentInChildren<BuildPrivilegeTrigger>();
            if (trig == null)
                Interface.Oxide.NextTick(() => {
                    trig = ent.GetComponentInChildren<BuildPrivilegeTrigger>();
                    if (trig == null) {
                        PrintWarning("Failed to update BuildingPrivlige: Missing BuildPrivilegeTrigger");
                        return;
                    }
                    updateTrigger(trig);
                });
            else
                updateTrigger(trig);
        }

        private bool updateTrigger(BuildPrivilegeTrigger bpt) {
            var col = bpt.GetComponent<UnityEngine.Collider>();
            var wasTrigger = true;
            if (col != null) { // should always be the case
                if (col is SphereCollider && Mathf.Approximately((col as SphereCollider).radius, radius))
                    return false; // Already a sphere with that radius
                wasTrigger = col.isTrigger;
                UnityEngine.Object.Destroy(col);
            }
            col = bpt.gameObject.AddComponent<SphereCollider>();
            col.transform.localPosition = Vector3.zero;
            col.transform.localScale = Vector3.one;
            (col as SphereCollider).radius = radius;
            col.isTrigger = wasTrigger;
            return true;
        }

        private void updateInfluence(uint privlidgePrefabID) {
            if (ignoreInfluence == pst.influenceIgnored)
                return;
            var attr = PrefabAttribute.server.Find(privlidgePrefabID);
            var socketBases = attr.Find<Socket_Base>();
            if (socketBases.Length < 1) {
                PrintWarning("Failed to update cupboard influence: Missing Socket_Base attribute");
                return;
            }
            var socketBase = socketBases[0];
            if (ignoreInfluence) {
                if (pst.influenceBackup == null)
                    pst.influenceBackup = socketBase.socketMods;
                socketBase.socketMods = socketBase.socketMods.Where(mod => mod.FailedPhrase.english != "You're trying to place too close to another cupboard").ToArray();
                pst.influenceIgnored = true;
                Puts("Cupboard influence restrictions are now ignored");
            } else {
                socketBase.socketMods = pst.influenceBackup;
                pst.influenceIgnored = false;
                Puts("Cupboard influence restrictions are no longer ignored");
            }
        }

        private class CupboardRadiusPersistence : MonoBehaviour
        {
            public bool influenceIgnored = false;
            public SocketMod[] influenceBackup = null;
        }
    }
}
